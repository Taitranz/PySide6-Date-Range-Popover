{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Date Range Popover","text":"<p><code>date_range_popover</code> packages a production-ready PySide6 date &amp; range picker that drops cleanly into data-entry tools and internal desktop apps.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>pip install valgo-date-range-popover\npython -m examples.basic_popover_demo\n</code></pre> <p>To embed the widget in your application:</p> <pre><code>from PySide6.QtWidgets import QApplication\nfrom date_range_popover import DatePickerConfig, DateRangePopover, PickerMode\n\napp = QApplication([])\nconfig = DatePickerConfig(mode=PickerMode.DATE)\npopover = DateRangePopover(config=config)\npopover.show()\napp.exec()\n</code></pre>"},{"location":"#documentation-map","title":"Documentation Map","text":"<ul> <li>Architecture explains the state manager, coordination   layer, and theming system.</li> <li>Embedding Guide shows how to configure the picker and wire it   into host applications.</li> <li>Public Surface enumerates the officially supported API.</li> <li>Python Reference is generated from docstrings using   <code>mkdocstrings</code>.</li> </ul>"},{"location":"#support-matrix","title":"Support Matrix","text":"<ul> <li>Python 3.10 \u2013 3.13</li> <li>PySide6 6.5 \u2013 6.7</li> <li>Linux, macOS, and Windows targets (Qt handles windowing differences).</li> </ul> <p>Report issues or start discussions on GitHub.</p>"},{"location":"ARCHITECTURE_DECISIONS/","title":"Architecture Decisions","text":"<p>This appendix records the most impactful design choices that shape <code>date_range_popover</code>. The intent is to make trade-offs explicit so future maintainers (or consumers) understand why things look the way they do.</p>"},{"location":"ARCHITECTURE_DECISIONS/#1-pure-state-manager-2024-01-10","title":"1. Pure State Manager (2024-01-10)","text":"<ul> <li>Decision: Keep all selection logic in <code>date_range_popover.core.state_logic</code>   and drive it via <code>DatePickerStateManager</code>.</li> <li>Why: PySide widgets are difficult to test in isolation. Separating state   transitions into a pure module enables deterministic unit tests and clears the   path for future non-Qt frontends.</li> <li>Trade-offs: Slightly more indirection inside coordinators, but it pays off   with property tests and reusable validation helpers.</li> </ul>"},{"location":"ARCHITECTURE_DECISIONS/#2-data-driven-theming-2024-01-18","title":"2. Data-Driven Theming (2024-01-18)","text":"<ul> <li>Decision: Represent themes as immutable dataclasses (palette + layout) and   feed them into a <code>StyleRegistry</code>.</li> <li>Why: Desktop apps frequently need branded widgets. Keeping colors and   dimensions declarative lets hosts load themes from files or factories without   rewriting widgets.</li> <li>Trade-offs: More boilerplate when adding new palette tokens, but the   strong typing prevents subtle style mismatches.</li> </ul>"},{"location":"ARCHITECTURE_DECISIONS/#3-qt-signals-callback-layer-2024-02-02","title":"3. Qt Signals + Callback Layer (2024-02-02)","text":"<ul> <li>Decision: Expose Qt signals (<code>date_selected</code>, <code>range_selected</code>) as the   canonical integration surface, but also ship a Python callback dispatcher.</li> <li>Why: Qt users expect signals, while other ecosystems prefer pure-Python   callbacks. Supporting both keeps the public API small and future-proofs the   component for non-Qt consumers.</li> <li>Trade-offs: <code>SelectionSnapshot</code> introduces a tiny amount of duplication,   but the ergonomic win outweighs it.</li> </ul>"},{"location":"ARCHITECTURE_DECISIONS/#4-strict-validation-by-default-2024-02-15","title":"4. Strict Validation by Default (2024-02-15)","text":"<ul> <li>Decision: Clamp every config value (dates, dimensions, colors) during   construction and fail fast with descriptive exceptions.</li> <li>Why: Host applications can feed partially trusted data into the picker   without writing bespoke sanitizers. It also makes CI quality gates meaningful.</li> <li>Trade-offs: Slightly longer construction time, but still <code>O(1)</code> and worth   the guarantees.</li> </ul>"},{"location":"ARCHITECTURE_DECISIONS/#5-reduced-motion-friendly-animations-2024-03-05","title":"5. Reduced Motion Friendly Animations (2024-03-05)","text":"<ul> <li>Decision: Keep the sliding-track animation isolated behind an   <code>AnimationStrategy</code> protocol so hosts can swap in reduced-motion strategies.</li> <li>Why: Accessibility requirements vary; providing a documented seam makes it   trivial to disable or customise animations.</li> <li>Trade-offs: Coordinators need one more dependency (<code>set_sliding_track_animator</code>),   but swapping animations is now a single-line change.</li> </ul>"},{"location":"architecture/","title":"Architecture &amp; Design Notes","text":"<p>The picker separates pure state management from Qt widgets so the core logic can be tested and reused independent of the GUI layer.</p>"},{"location":"architecture/#high-level-flow","title":"High-Level Flow","text":"<ol> <li>State Manager (<code>DatePickerStateManager</code>) keeps the canonical selection    state, clamps values to <code>[min_date, max_date]</code>, and exposes granular signals.</li> <li>Coordinator listens to state changes and updates UI components (button    strip, calendar, date/time inputs).</li> <li>Widgets render the state and forward user input back through the    coordinator.</li> </ol> <p>This creates a predictable loop:</p> <pre><code>User input -&gt; Coordinator -&gt; State manager -&gt; Signals -&gt; Widgets\n</code></pre>"},{"location":"architecture/#pure-logic-vs-gui-modules","title":"Pure Logic vs GUI Modules","text":"<ul> <li>Pure Python: <code>date_range_popover.core.state_logic</code>, <code>date_range_popover.utils.*</code>,   and validation helpers. These modules never import Qt widgets and can be unit   tested in headless environments.</li> <li>GUI Modules: Components under <code>date_range_popover.components.*</code>,   animators, and the popover widget. They depend on PySide6 for rendering.</li> </ul> <p>Keeping logic isolated enables property-based tests (see <code>tests/properties/test_invariants.py</code>) and makes it feasible to drive a future non-Qt frontend from the same state/validation layer.</p>"},{"location":"architecture/#theming-styling","title":"Theming &amp; Styling","text":"<p><code>Theme</code> combines a <code>ColorPalette</code> and <code>LayoutConfig</code>. The palette validates every hex string, while the layout clamps numeric values via <code>validate_dimension</code>. <code>StyleRegistry</code> converts those tokens into widget-specific style objects, and <code>StyleManager</code> applies them to widgets at runtime. Registering a new palette or layout does not require touching widget code.</p>"},{"location":"architecture/#picker-modes","title":"Picker Modes","text":"<p><code>PickerMode</code> currently defines two values:</p> <ul> <li><code>DATE</code> \u2013 single-date selection with a compact layout.</li> <li><code>CUSTOM_RANGE</code> \u2013 dual-date inputs plus additional actions.</li> </ul> <p>Switching modes triggers a sliding indicator animation (<code>SlideAnimator</code>) and resizes the popover to pre-defined heights, but the state manager retains the underlying selection so users can bounce between modes without losing progress.</p>"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>State transitions (selecting dates, switching modes, clamping bounds) are   <code>O(1)</code> operations because the state manager stores at most two <code>QDate</code> objects   and a single visible-month reference.</li> <li>Calendar rendering is <code>O(#visible-days)</code>\u2014roughly 42 cells for standard   monthly grids\u2014so painting cost stays constant regardless of min/max ranges.</li> <li>Animations run on a lightweight timer that updates only the sliding track\u2019s   geometry; no expensive scene graphs or off-screen buffers are used.</li> <li>Memory footprint stays bounded: the state manager holds <code>&lt;= 2</code> <code>QDate</code>   objects, and themes are immutable dataclasses that can be reused across   multiple widget instances.</li> <li>I/O is limited to Qt event handling; there are no background threads or   network calls.</li> <li>Large ranges (multi-year) remain responsive because navigation only clamps   the month pointer and never materialises entire date ranges.</li> </ul>"},{"location":"architecture/#signals-threading","title":"Signals &amp; Threading","text":"<p>All signals fire on the Qt GUI thread. The library does not spawn background threads, so embedder code can safely mutate UI state inside signal handlers as long as it adheres to Qt's threading rules.</p>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<p>Upcoming documentation in <code>docs/extending.md</code> will cover:</p> <ul> <li>Registering custom themes and palettes.</li> <li>Hooking into range selection via callbacks in addition to Qt signals.</li> <li>Replacing calendar renderers while reusing the state manager.</li> </ul> <p>If you plan to depend on internals, prefer filing an issue so we can discuss promoting new hooks to the supported surface.</p>"},{"location":"embedding/","title":"Embedding Guide","text":""},{"location":"embedding/#embedding-input-sanitisation","title":"Embedding &amp; Input Sanitisation","text":"<p><code>DateRangePopover</code> is designed to live inside larger desktop apps, which often means configuration data originates outside of your direct control (settings files, remote APIs, user-editable forms, etc.). This guide explains how to safely bridge that external input into the picker.</p>"},{"location":"embedding/#1-normalise-external-data","title":"1. Normalise external data","text":"<p>Always convert raw inputs into concrete Python types before building a <code>DatePickerConfig</code>. For example, parse ISO date strings into <code>QDate</code> objects and clamp integers to sensible ranges.</p> <pre><code>from PySide6.QtCore import QDate\n\ndef parse_iso_date(value: str | None) -&gt; QDate | None:\n    if not value:\n        return None\n    candidate = QDate.fromString(value, \"yyyy-MM-dd\")\n    return candidate if candidate.isValid() else None\n</code></pre>"},{"location":"embedding/#2-reuse-the-built-in-validators","title":"2. Reuse the built-in validators","text":"<p>After you have provisional types, call the validation helpers shipped with the library to double check everything. They raise descriptive exceptions you can surface to users or logs.</p> <pre><code>from date_range_popover.validation import validate_date_range, validate_qdate\n\ndef sanitise_payload(payload: dict) -&gt; tuple[QDate | None, QDate | None]:\n    start = parse_iso_date(payload.get(\"start\"))\n    end = parse_iso_date(payload.get(\"end\"))\n    return validate_date_range(start, end, field_name=\"user_payload\")\n\ndef sanitise_anchor(date_str: str | None) -&gt; QDate | None:\n    return validate_qdate(parse_iso_date(date_str), field_name=\"anchor\", allow_none=True)\n</code></pre>"},{"location":"embedding/#3-construct-datepickerconfig-inside-try-except","title":"3. Construct <code>DatePickerConfig</code> inside <code>try</code> / <code>except</code>","text":"<p>Wrap config construction so you can gracefully fallback if someone hands you a bad payload. <code>DatePickerConfig</code> re-validates everything in <code>__post_init__</code>, so even if the embedding code misses something you'll get a deterministic exception.</p> <pre><code>from date_range_popover import DatePickerConfig, DateRange, PickerMode\n\ndef build_config(raw: dict) -&gt; DatePickerConfig:\n    range_start, range_end = sanitise_payload(raw.get(\"range\", {}))\n    try:\n        return DatePickerConfig(\n            mode=PickerMode[raw.get(\"mode\", \"DATE\").upper()],\n            initial_range=DateRange(start_date=range_start, end_date=range_end),\n            min_date=sanitise_anchor(raw.get(\"min\")),\n            max_date=sanitise_anchor(raw.get(\"max\")),\n            width=int(raw.get(\"width\", 302)),\n            height=int(raw.get(\"height\", 580)),\n        )\n    except (ValueError, KeyError, Exception) as exc:\n        # Map to your own error reporting; fall back to safe defaults.\n        raise RuntimeError(\"Invalid picker configuration\") from exc\n</code></pre>"},{"location":"embedding/#4-handle-runtime-validation-failures","title":"4. Handle runtime validation failures","text":"<p>The picker emits strong types (e.g. <code>DateRange</code> instances) and its state manager clamps selections to the configured bounds. If you still need to double-check at the edge of your system, reuse the validators:</p> <pre><code>def on_range_selected(date_range: DateRange) -&gt; None:\n    start, end = validate_date_range(\n        date_range.start_date,\n        date_range.end_date,\n        field_name=\"range_selected_signal\",\n        allow_partial=False,\n    )\n    persist_selection(start, end)\n</code></pre>"},{"location":"embedding/#5-clean-up-embedded-widgets","title":"5. Clean up embedded widgets","text":"<p>If you dynamically create/destroy popovers, call <code>DateRangePicker.cleanup</code> when you remove them. This stops animations and releases Qt objects so subsequent embeddings start from a clean slate.</p> <pre><code>popover = DateRangePopover(config=build_config(payload))\npopover.destroyed.connect(popover.cleanup)\n</code></pre>"},{"location":"embedding/#6-read-selection-state-via-properties","title":"6. Read selection state via properties","text":"<p>The public API exposes <code>selected_date</code> and <code>selected_range</code> properties (instead of <code>get_*</code> methods). Properties make it trivial to inspect the current state when wiring menus or command handlers:</p> <pre><code>if popover.selected_range.end_date is not None:\n    print(\"Range locked in:\", popover.selected_range)\n</code></pre> <p>Refer back to <code>README.md</code> for high-level usage and the demo under <code>examples/basic_popover_demo.py</code> for a runnable reference implementation.</p>"},{"location":"extending/","title":"Extending the Picker","text":"<p>The library exposes several hooks so you can tailor the picker without forking the codebase.</p>"},{"location":"extending/#custom-themes","title":"Custom Themes","text":"<p>Custom palettes/layouts let you brand the picker without touching the widget code. Two common approaches:</p> <ol> <li>Static Python definition \u2013 great for themes embedded directly in source    control:</li> </ol> <p>```python    from date_range_popover import DatePickerConfig    from date_range_popover.styles.theme import ColorPalette, LayoutConfig, Theme</p> <p>ACCENT_THEME = Theme(        palette=ColorPalette(            window_background=\"#101820\",            track_indicator_color=\"#f2aa4c\",            calendar_today_background=\"#f2aa4c\",        ),        layout=LayoutConfig(window_min_width=360, action_button_height=52),    )</p> <p>config = DatePickerConfig(theme=ACCENT_THEME)    ```</p> <ol> <li>Data-driven themes \u2013 load palettes/layouts from JSON/YAML so they can be    tweaked without code changes:</li> </ol> <p>```python    import json    from date_range_popover.styles.theme import theme_from_mapping</p> <p>payload = json.load(open(\"theme.json\", \"r\", encoding=\"utf-8\"))    custom_theme = theme_from_mapping(payload)    config = DatePickerConfig(theme=custom_theme)    ```</p> <p>The <code>examples/custom_theme_demo.py</code> script renders two themes side-by-side (accent dark + pastel light) to illustrate how palette/layout swaps ripple through the UI.</p> <p>For dynamic themes, implement the <code>ThemeProvider</code> protocol\u2014useful when themes are supplied by plugins or remote endpoints:</p> <pre><code>from dataclasses import dataclass\nfrom date_range_popover.styles.theme import Theme, ThemeProvider, theme_from_mapping\n\n@dataclass\nclass FileThemeProvider(ThemeProvider):\n    path: str\n\n    def build_theme(self) -&gt; Theme:\n        with open(self.path, \"r\", encoding=\"utf-8\") as handle:\n            return theme_from_mapping(json.load(handle))\n</code></pre>"},{"location":"extending/#style-variants","title":"Style Variants","text":"<p><code>StyleRegistry</code> exposes <code>register_button_style</code>, <code>register_calendar_style</code>, and <code>register_input_style</code> so you can inject additional presets at runtime:</p> <pre><code>registry = StyleRegistry()\nregistry.register_button_style(\"danger\", ButtonStyleConfig(...))\nstyle_manager = StyleManager(registry)\nstyle_manager.apply_basic_button(button, variant=\"danger\")\n</code></pre>"},{"location":"extending/#selection-callbacks","title":"Selection Callbacks","text":"<p>Qt signals remain the primary integration point, but you can layer additional observer interfaces on top of them to align with your application's plugin surface.</p> <p><code>DateRangePopover</code> exposes a <code>register_selection_callback</code> method that accepts callables receiving a <code>SelectionSnapshot</code>:</p> <pre><code>from date_range_popover.types.selection import SelectionSnapshot\n\ndef log_selection(snapshot: SelectionSnapshot) -&gt; None:\n    print(\"Mode:\", snapshot.mode.name, \"Range:\", snapshot.selected_range)\n\npopover.register_selection_callback(log_selection)\n</code></pre> <p>Callbacks fire synchronously on the Qt GUI thread, so keep handlers lightweight. Unregister them with <code>deregister_selection_callback</code>.</p>"},{"location":"extending/#building-custom-dispatchers","title":"Building Custom Dispatchers","text":"<p>When you need a richer observer API (e.g., to mirror existing extension hooks) wrap the Qt signals once and fan out updates yourself. See <code>examples/extension_hooks_demo.py</code> for a complete dispatcher + observer implementation:</p> <pre><code>class SelectionObserver(Protocol):\n    def on_single_date(self, date: QDate) -&gt; None: ...\n    def on_range(self, date_range: DateRange) -&gt; None: ...\n\ndispatcher = SelectionDispatcher()\ndispatcher.bind(popover)          # Wire Qt signals once\ndispatcher.register(ConsoleObserver())  # Fan-out to arbitrary callbacks\n</code></pre> <p>This pattern keeps picker internals untouched while still presenting a domain-specific API to the rest of your application.</p>"},{"location":"extending/#future-hooks","title":"Future Hooks","text":"<p>The architecture keeps state management Qt-free, which enables future extension points such as:</p> <ul> <li>Swapping calendar renderers while reusing the state manager.</li> <li>Plugging in alternative animation strategies.</li> <li>Serialising themes to/from remote sources.</li> </ul> <p>File an issue if you need a specific hook; promoting it to the supported surface is usually easier than maintaining a fork.</p>"},{"location":"extending/#design-rationale","title":"Design Rationale","text":"<ul> <li>Pure state logic lives in <code>date_range_popover.core.state_logic</code>, making it   trivial to test or port to another UI framework.</li> <li>Style isolation keeps palette/layout data separate from widgets so themes   can be swapped dynamically (see the demo linked above).</li> <li>Signal indirection ensures you can layer the dispatcher pattern without   subclassing Qt widgets.</li> </ul>"},{"location":"roadmap/","title":"Roadmap &amp; Design Notes","text":"<p>This page captures upcoming ideas, open questions, and constraints that guide the evolution of <code>date_range_popover</code>. It is aspirational\u2014items ship when they have owners.</p>"},{"location":"roadmap/#near-term","title":"Near-Term","text":"<ul> <li>Keyboard navigation &amp; accessibility: expose a11y roles on calendar cells,   add arrow-key navigation, and document focus order.</li> <li>Time-aware mode: extend <code>PickerMode</code> with a time-inclusive variant so   range selection can optionally require start/end times.</li> <li>Theme import/export: allow serialising palettes/layouts to JSON/YAML and   add CLI helpers for generating starter themes.</li> <li>More tests: add Qt screenshot regression tests for high-DPI and RTL   layouts, plus fuzzing for configuration validators.</li> </ul>"},{"location":"roadmap/#medium-term","title":"Medium-Term","text":"<ul> <li>Multiple calendar systems: abstract <code>QDate</code> usage so alternate calendars   (ISO week, fiscal calendars, etc.) can plug in.</li> <li>Animation strategy injection: swap the slide indicator animation with   easing curves or disabled animations for accessibility.</li> <li>State-machine visualiser: ship a developer overlay that shows the current   <code>DatePickerState</code> to simplify debugging embedder issues.</li> <li>Plugin registry: document a convention for discovering theme providers and   selection callbacks via entry points (useful for larger apps).</li> </ul>"},{"location":"roadmap/#long-term-research","title":"Long-Term / Research","text":"<ul> <li>Cross-toolkit frontends: leverage the pure <code>core/state_logic</code> module to   drive frontends in other UI frameworks (Tkinter, React via Pyodide, etc.).</li> <li>Internationalisation: integrate Qt's translation system so labels/month   names come from <code>.qm</code> files rather than hard-coded strings.</li> <li>Async state coordination: explore asyncio-friendly state managers so the   picker can live inside hybrid desktop/web runtimes.</li> </ul>"},{"location":"roadmap/#not-planned-yet","title":"Not Planned (Yet)","text":"<ul> <li>Building a scheduling/timeline UI (this component stays focused on popovers).</li> <li>Supporting legacy Python versions (&lt;3.10).</li> <li>Shipping compiled resources; assets remain as SVGs for now.</li> </ul> <p>Have an idea that's not listed? Open an issue so we can capture it here.</p>"},{"location":"api/deprecation_policy/","title":"Deprecation Policy","text":"<p>This document clarifies how the <code>date_range_popover</code> project introduces, communicates, and ultimately removes breaking changes so embedders can plan upgrades with confidence.</p>"},{"location":"api/deprecation_policy/#versioning-model","title":"Versioning Model","text":"<ul> <li>The project follows Semantic Versioning. Breaking API   changes only occur in major releases (<code>vX.0.0</code>).</li> <li>Minor releases (<code>vX.Y.0</code>) may introduce new functionality but never remove or   silently change documented behavior.</li> <li>Patch releases (<code>vX.Y.Z</code>) contain only bug fixes and documentation updates.</li> </ul>"},{"location":"api/deprecation_policy/#deprecation-timeline","title":"Deprecation Timeline","text":"<ol> <li>Announcement \u2013 Deprecated APIs are documented in the changelog, README,    and relevant docs with guidance on preferred alternatives.</li> <li>Warning Period \u2013 The existing implementation continues to work for at    least two minor releases while emitting a <code>DeprecationWarning</code>.</li> <li>Removal \u2013 The API is removed in the next major release after the warning    window closes.</li> </ol> <p>Example:</p> <ul> <li><code>v1.2.0</code> introduces a new API and marks the older method as deprecated.</li> <li><code>v1.3.x</code> retains the deprecated method but continues to emit warnings.</li> <li><code>v2.0.0</code> removes the deprecated method.</li> </ul>"},{"location":"api/deprecation_policy/#warning-mechanics","title":"Warning Mechanics","text":"<p>Use standard library warnings to surface upcoming removals without interrupting host applications:</p> <pre><code>import warnings\n\ndef legacy_method(*args, **kwargs):\n    warnings.warn(\n        \"legacy_method() is deprecated and will be removed in v2.0.0; \"\n        \"use modern_method() instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return modern_method(*args, **kwargs)\n</code></pre>"},{"location":"api/deprecation_policy/#documentation-requirements","title":"Documentation Requirements","text":"<p>Every deprecation must include:</p> <ul> <li>A changelog entry with the first release that introduced the warning.</li> <li>Updated API references noting the replacement and removal timeline.</li> <li>Inline docstrings that mention the deprecation and link to migration guidance.</li> </ul>"},{"location":"api/deprecation_policy/#guarantee-scope","title":"Guarantee Scope","text":"<p>Versioned behavior guarantees (see <code>docs/api/public_api.md</code>) remain valid unless a deprecation notice states otherwise. Internal modules may evolve without notice, but any object listed in the public API reference follows this policy.</p>"},{"location":"api/extension_points/","title":"Extension Points","text":"<p>This document enumerates the supported hooks for extending <code>date_range_popover</code> without vendoring the entire library. Anything listed here is considered stable for releases <code>&gt;= 0.1.0</code>. Internal modules not referenced here can change at any time.</p>"},{"location":"api/extension_points/#theme-providers","title":"Theme Providers","text":"<ul> <li>Implement the <code>ThemeProvider</code> protocol to lazily load   palettes/layouts (for example, from JSON, YAML, or a database).</li> <li>Pass the provider into <code>StyleRegistry</code> or <code>StyleManager.use_theme()</code> and the   picker will resolve the underlying <code>Theme</code> on demand.</li> <li>See <code>examples/custom_theme_demo.py</code> for two concrete implementations.</li> </ul>"},{"location":"api/extension_points/#style-registry-variants","title":"Style Registry Variants","text":"<ul> <li><code>StyleRegistry.register_button_style</code>, <code>register_calendar_style</code>, and   <code>register_input_style</code> let you add named style variants that can be activated   at runtime.</li> <li><code>StyleManager.apply_*</code> helpers accept variant names (<code>primary</code>, <code>accent</code>,   <code>ghost</code>, etc.) and propagate them to widgets. Custom variants can use any   string identifier.</li> </ul>"},{"location":"api/extension_points/#selection-callbacks","title":"Selection Callbacks","text":"<ul> <li><code>DateRangePicker.register_selection_callback</code> accepts callables conforming to   the <code>SelectionCallback</code> protocol. Each callback receives   a <code>SelectionSnapshot</code> describing the current state.</li> <li>Callbacks fire synchronously on the Qt GUI thread. Keep handlers short-lived or   offload work to background threads.</li> <li>For richer observer APIs, wrap the Qt signals once (see   <code>examples/extension_hooks_demo.py</code>) and fan out to your own plugin surface.</li> </ul>"},{"location":"api/extension_points/#animation-strategies","title":"Animation Strategies","text":"<ul> <li>The <code>AnimationStrategy</code> protocol describes the   contract for sliding-track animations.</li> <li>Swap in your own implementation (e.g., easing curves, reduced motion) and pass   it to the coordinator via <code>set_sliding_track_animator</code>.</li> </ul>"},{"location":"api/extension_points/#coordinator-hooks","title":"Coordinator Hooks","text":"<ul> <li><code>DatePickerCoordinator</code> exposes registration methods for the button strip,   calendar, date-time selector, and sliding track. Embedders can swap widgets so   long as they match the expected interfaces.</li> <li>The coordinator also exposes <code>handle_calendar_selection</code>, <code>switch_mode</code>, and   <code>select_date</code> helpers for advanced embedding scenarios.</li> </ul>"},{"location":"api/extension_points/#configuration-sanitizers","title":"Configuration Sanitizers","text":"<ul> <li>Validation helpers under <code>date_range_popover.validation</code> (e.g.,   <code>validate_hex_color</code>, <code>validate_dimension</code>) are public so hosting apps can   reuse the exact same sanitisation logic when accepting user input.</li> </ul>"},{"location":"api/extension_points/#roadmap-for-future-hooks","title":"Roadmap for Future Hooks","text":"<ul> <li>The architecture keeps the core state logic Qt-free, making it feasible to   add alternate frontends (Tkinter, web-based) without rewriting validation or   selection invariants.</li> <li>If you need a hook not listed here, open an issue\u2014promoting new extension   points is much easier than maintaining a fork.</li> </ul>"},{"location":"api/public_api/","title":"Public API Surface","text":"<p>The objects documented in this file represent the supported, stable surface area of <code>date_range_popover</code>. Everything else (managers, widgets, coordinators, validators, etc.) is considered internal and can change without notice. Breaking changes to the sections below follow semantic versioning once the package reaches <code>v1.0.0</code>.</p>"},{"location":"api/public_api/#stability-contract","title":"Stability Contract","text":"<ul> <li>Import only from the package root (<code>date_range_popover</code>) or the modules listed   here.</li> <li>Signals, methods, and properties that are not documented should be treated as   internal helpers.</li> <li>All guarantees apply to releases <code>&gt;= 1.0.0</code>. Pre-release builds may change   without deprecation.</li> <li>Deprecation timelines and expectations are documented in   <code>docs/api/deprecation_policy.md</code>.</li> </ul>"},{"location":"api/public_api/#versioned-behavior-guarantees","title":"Versioned Behavior Guarantees","text":"<p>The following behaviors are contractually guaranteed beginning with <code>v0.1.0</code> and apply to all future releases unless a formal deprecation has been announced.</p> <ul> <li><code>selected_range</code> is always either <code>None</code> or a normalized <code>DateRange</code> whose   <code>start_date &lt;= end_date</code>.</li> <li><code>DatePickerStateManager</code> clamps every selection attempt to <code>[min_date, max_date]</code>   and raises <code>InvalidDateError</code> when the bounds are violated.</li> <li><code>DatePickerConfig</code> replaces a missing <code>max_date</code> with <code>QDate.currentDate()</code>,   ensuring future dates remain disabled by default.</li> <li><code>DateRangePopover</code> never mutates <code>DatePickerConfig</code> instances passed to it;   treat configs as immutable snapshots.</li> <li>All Qt signals (<code>date_selected</code>, <code>range_selected</code>, <code>cancelled</code>) fire on the UI   thread and emit defensive copies of <code>QDate</code>/<code>DateRange</code>.</li> <li>Mode transitions are idempotent; reassigning the active mode to its current value   does not emit duplicate signals.</li> <li>Theme validation rejects invalid hex codes and zero/negative dimensions before any   widgets are instantiated.</li> </ul>"},{"location":"api/public_api/#daterangepopover-daterangepicker","title":"<code>DateRangePopover</code> / <code>DateRangePicker</code>","text":"<ul> <li>Location: <code>from date_range_popover import DateRangePopover, DateRangePicker</code></li> <li>Purpose: Turn-key widgets that expose a minimal embedding surface.</li> <li>Stable members:</li> <li>Properties: <code>selected_date</code>, <code>selected_range</code></li> <li>Methods: <code>set_mode(mode: PickerMode)</code>, <code>reset()</code>, <code>cleanup()</code></li> <li>Qt signals: <code>date_selected(QDate)</code>, <code>range_selected(DateRange)</code>,     <code>cancelled()</code></li> <li>Guarantees:</li> <li><code>selected_date</code> returns an invalid <code>QDate</code> when no single-date selection     exists; otherwise it is clamped to <code>[min_date, max_date]</code>.</li> <li><code>selected_range</code> always has <code>start &lt;= end</code> when both endpoints are present.</li> <li>Signals emit on the Qt GUI thread in the following order:<ol> <li><code>date_selected</code> / <code>range_selected</code></li> <li><code>cancelled</code> (for dismissals)</li> </ol> </li> <li><code>reset()</code> restores the initial configuration without creating a new widget.</li> <li>Methods must be invoked on the Qt GUI thread.</li> </ul>"},{"location":"api/public_api/#datepickerconfig","title":"<code>DatePickerConfig</code>","text":"<ul> <li>Location: <code>from date_range_popover import DatePickerConfig</code></li> <li>Purpose: Validated configuration object consumed by the picker widgets.</li> <li>Stable fields:</li> <li>Layout: <code>width</code>, <code>height</code>, <code>theme</code></li> <li>Selection defaults: <code>initial_date</code>, <code>initial_range</code>, <code>mode</code></li> <li>Bounds: <code>min_date</code>, <code>max_date</code></li> <li>Time controls: <code>time_step_minutes</code></li> <li>Guarantees:</li> <li><code>max_date</code> defaults to <code>QDate.currentDate()</code> when omitted.</li> <li><code>initial_range</code> and <code>initial_date</code> are clamped to <code>[min_date, max_date]</code>.</li> <li>Instantiating with invalid values raises <code>InvalidConfigurationError</code>.</li> </ul>"},{"location":"api/public_api/#daterange","title":"<code>DateRange</code>","text":"<ul> <li>Location: <code>from date_range_popover import DateRange</code></li> <li>Purpose: Immutable container used by signals and configs.</li> <li>Stable attributes: <code>start_date</code>, <code>end_date</code>, <code>start_time</code>, <code>end_time</code></li> <li>Guarantees:</li> <li>When both endpoints exist, <code>start_date &lt;= end_date</code>.</li> <li>Time values are either both valid <code>QTime</code> instances or <code>None</code>.</li> <li>Instances are safe to cache; they never return references to internal state.</li> </ul>"},{"location":"api/public_api/#pickermode","title":"<code>PickerMode</code>","text":"<ul> <li>Location: <code>from date_range_popover import PickerMode</code></li> <li>Values: <code>PickerMode.DATE</code>, <code>PickerMode.CUSTOM_RANGE</code></li> <li>Guarantees: Additional modes may be added in minor releases, but existing   enum values will not change or be removed without deprecation.</li> </ul>"},{"location":"api/public_api/#behavior-guarantees","title":"Behavior Guarantees","text":"<ul> <li><code>range_selected</code> always emits a fully normalized <code>DateRange</code> with defensive   copies of <code>QDate</code> objects.</li> <li>The state manager clamps every selection to the configured bounds. Invalid   inputs raise <code>InvalidDateError</code>.</li> <li><code>DateRangePopover</code> never mutates <code>DatePickerConfig</code> instances passed to the   constructor; treat configs as immutable.</li> <li>The library does not spawn threads; all callbacks and signals fire on the Qt   GUI thread.</li> <li>Deprecation notices remain in place for at least two minor releases; see the   dedicated deprecation policy for migration expectations.</li> </ul>"},{"location":"api/public_api/#non-guaranteed-internal-modules","title":"Non-Guaranteed / Internal Modules","text":"<p>The following areas are internal and subject to change between releases:</p> <ul> <li><code>date_range_popover.components.*</code></li> <li><code>date_range_popover.managers.*</code></li> <li><code>date_range_popover.utils.*</code></li> <li><code>date_range_popover.styles.*</code></li> <li><code>date_range_popover.validation.*</code></li> </ul> <p>Rely on them only if you are prepared to vendor or fork the library.</p>"},{"location":"api/reference/","title":"Python API Reference","text":""},{"location":"api/reference/#date_range_popover.DatePickerConfig","title":"<code>DatePickerConfig</code>  <code>dataclass</code>","text":"<p>Canonical configuration object consumed by :class:<code>DateRangePicker</code>.</p> <p>The dataclass performs defensive sanitisation in <code>__post_init__</code> so embedding contexts can accept partially trusted input (for example, values entered in another widget) and still end up with a predictable picker. All numeric dimensions are clamped via :func:<code>validate_dimension</code>, all dates flow through :func:<code>validate_qdate</code>, and ranges are validated by :func:<code>validate_date_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Fixed window width in pixels.</p> <code>window_min_width</code> <code>height</code> <code>int</code> <p>Fixed window height in <code>DATE</code> mode.</p> <code>window_min_height</code> <code>theme</code> <code>Theme</code> <p>Theme object containing palette and layout tokens.</p> <code>Theme()</code> <code>initial_date</code> <code>QDate | None</code> <p>Single-date default selection.</p> <code>None</code> <code>initial_range</code> <code>DateRange | None</code> <p>Pre-selected range that overrides <code>initial_date</code>.</p> <code>None</code> <code>mode</code> <code>PickerMode</code> <p>Initial :class:<code>PickerMode</code> (<code>DATE</code> or <code>CUSTOM_RANGE</code>).</p> <code>DATE</code> <code>min_date</code> <code>QDate | None</code> <p>Absolute lower bound for selection/navigation.</p> <code>None</code> <code>max_date</code> <code>QDate | None</code> <p>Absolute upper bound for selection/navigation. Defaults to <code>QDate.currentDate()</code> when omitted to prevent future selections.</p> <code>None</code> <code>time_step_minutes</code> <code>int</code> <p>Step interval for the time selector component.</p> <code>15</code> <p>Raises:</p> Type Description <code>InvalidConfigurationError</code> <p>For any inconsistent value (dimensions out of bounds, <code>min_date &gt; max_date</code>, invalid <code>Theme</code> instances, etc.).</p> Example <p>from PySide6.QtCore import QDate DatePickerConfig( ...     mode=PickerMode.CUSTOM_RANGE, ...     min_date=QDate(2023, 1, 1), ...     max_date=QDate(2024, 12, 31), ... )</p>"},{"location":"api/reference/#date_range_popover.DatePickerConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Clamp and validate configuration values.</p> <p>Host applications frequently build <code>DatePickerConfig</code> instances from external inputs (API payloads, settings files, etc.). This lifecycle hook ensures all derived values are deterministic before the widget reads them, which significantly reduces the amount of manual sanitisation embedding contexts need to write.</p>"},{"location":"api/reference/#date_range_popover.DateRange","title":"<code>DateRange</code>  <code>dataclass</code>","text":"<p>Immutable date/time container shared across the public API.</p> <p>The dataclass validates its inputs eagerly so host applications can rely on a fully normalized range when they receive it via picker signals. Dates are sanitised with :func:<code>date_range_popover.validation.validate_date_range</code> while time values are checked for <code>QTime.isValid</code>. <code>None</code> values are preserved so callers can intentionally pass open ranges.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>QDate | None</code> <p>Inclusive start of the range (<code>None</code> for an open range).</p> <code>None</code> <code>end_date</code> <code>QDate | None</code> <p>Inclusive end of the range (<code>None</code> for an open range).</p> <code>None</code> <code>start_time</code> <code>QTime | None</code> <p>Optional time paired with <code>start_date</code>.</p> <code>None</code> <code>end_time</code> <code>QTime | None</code> <p>Optional time paired with <code>end_date</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidConfigurationError</code> <p>If any <code>QDate</code> or <code>QTime</code> value is invalid or if <code>start_date</code> is after <code>end_date</code>.</p> Example <p>from PySide6.QtCore import QDate DateRange( ...     start_date=QDate(2024, 1, 1), ...     end_date=QDate(2024, 1, 10), ... )</p>"},{"location":"api/reference/#date_range_popover.DateRange.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Normalise and validate date/time fields immediately after creation.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker","title":"<code>DateRangePicker</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>High-level facade for constructing and embedding the popover.</p> <p>The widget exposes a small surface area focused on things host applications care about: reacting to user selections (via Qt signals), reading the current selection, switching between picker modes, and resetting/cleaning up resources. Everything else\u2014layout, component wiring, state transitions\u2014is encapsulated so the embedding code stays simple.</p> Example <p>picker = DateRangePicker(DatePickerConfig(mode=PickerMode.DATE)) picker.date_selected.connect(lambda d: print(d.toString(\"yyyy-MM-dd\"))) picker.show()</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker--signals","title":"Signals","text":"<p>date_selected(QDate)     Emitted when a single date is confirmed. An invalid <code>QDate</code> indicates     that no date is currently selected. range_selected(DateRange)     Emitted when both ends of the range are locked in. cancelled()     Emitted when the user dismisses or cancels the popover.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.selected_date","title":"<code>selected_date</code>  <code>property</code>","text":"<p>Currently selected single date.</p> <p>Returns:</p> Type Description <code>QDate</code> <p>A defensive <code>QDate</code> copy representing the active single-date</p> <code>QDate</code> <p>selection. The value is invalid (<code>QDate()</code>) when no single date is</p> <code>QDate</code> <p>locked in.</p> Guarantees <ul> <li>When valid, the date always respects <code>config.min_date</code> /   <code>config.max_date</code>.</li> <li>The returned object is never shared with internal state.</li> </ul>"},{"location":"api/reference/#date_range_popover.DateRangePicker.selected_range","title":"<code>selected_range</code>  <code>property</code>","text":"<p>Currently selected range (may be partial).</p> <p>Returns:</p> Type Description <code>DateRange</code> <p>class:<code>DateRange</code>: a defensive copy with the best-known endpoints.</p> <code>DateRange</code> <p>Missing endpoints remain <code>None</code> so callers can differentiate</p> <code>DateRange</code> <p>between partial and complete selections.</p> Guarantees <ul> <li>When present, endpoints always satisfy <code>start &lt;= end</code>.</li> <li>Every endpoint is clamped to <code>[min_date, max_date]</code>.</li> </ul>"},{"location":"api/reference/#date_range_popover.DateRangePicker.__init__","title":"<code>__init__(config=None, parent=None)</code>","text":"<p>Build a picker instance using the provided configuration.</p> <p>The constructor clones all configuration values and initialises the internal managers immediately, so callers should treat the config object as immutable after passing it in.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DatePickerConfig | None</code> <p>Optional :class:<code>DatePickerConfig</code>. Defaults to a new instance when omitted.</p> <code>None</code> <code>parent</code> <code>QWidget | None</code> <p>Optional widget parent for lifetime management.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidConfigurationError</code> <p>Propagated when <code>config</code> contains invalid values (for example, <code>min_date &gt; max_date</code>).</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.cleanup","title":"<code>cleanup()</code>","text":"<p>Release long-lived objects and stop active animations.</p> <p>Call this during application teardown or when removing the widget from a complex embedding scenario to make sure timers/animations are cleaned up.</p> Notes <p>The widget becomes unusable after <code>cleanup</code>; create a new instance if you need to re-mount the UI.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.deregister_selection_callback","title":"<code>deregister_selection_callback(callback)</code>","text":"<p>Remove a previously registered callback.</p> <p>Calling this method with an unknown callback is a no-op.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.register_selection_callback","title":"<code>register_selection_callback(callback)</code>","text":"<p>Register a Python callback that mirrors the Qt selection signals.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>SelectionCallback</code> <p>Callable that receives a :class:<code>SelectionSnapshot</code>.</p> required Notes <p>Callbacks are invoked synchronously on the Qt GUI thread. They are in addition to (not instead of) the Qt signals, which remain the canonical integration surface for Qt consumers.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.reset","title":"<code>reset()</code>","text":"<p>Reset the picker state to match the initial configuration.</p> <p>This method clears animations, re-applies selection defaults, and ensures the coordinator redraws UI components.</p> Notes <p>Safe to call any time the host wants to discard in-progress user input. Must run on the Qt GUI thread.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.set_mode","title":"<code>set_mode(mode)</code>","text":"<p>Switch the picker to the provided :class:<code>PickerMode</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PickerMode</code> <p><code>PickerMode.DATE</code> or <code>PickerMode.CUSTOM_RANGE</code>.</p> required Notes <p>Must be invoked from the Qt GUI thread because it drives widget mutations and animations.</p>"},{"location":"api/reference/#date_range_popover.DateRangePopover","title":"<code>DateRangePopover</code>","text":"<p>               Bases: <code>DateRangePicker</code></p> <p>Turn-key widget that wraps :class:<code>DateRangePicker</code> for embedding.</p> <p>Importing :class:<code>DateRangePopover</code> keeps application code terse; it exposes the same public API as :class:<code>DateRangePicker</code> but ships with a default configuration. That makes it handy for quick experiments and demos. Pass a pre-sanitised :class:<code>DatePickerConfig</code> so constraints (min/max dates, layout bounds, themes) stay explicit at construction time.</p> Example <p>popover = DateRangePopover() popover.range_selected.connect(lambda r: print(r.start_date, r.end_date)) popover.show()</p>"},{"location":"api/reference/#date_range_popover.DateRangePopover.__init__","title":"<code>__init__(config=None, parent=None)</code>","text":"<p>Build the popover using the provided configuration and optional parent.</p> <p>:param config: Optional :class:<code>DatePickerConfig</code>. Falls back to     defaults. :param parent: Parent widget responsible for lifetime management.</p>"}]}